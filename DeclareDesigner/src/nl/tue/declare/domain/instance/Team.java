/* Generated by Together */

package nl.tue.declare.domain.instance;

import java.util.*;

import nl.tue.declare.domain.model.*;
import nl.tue.declare.domain.organization.*;

public class Team {

  private Assignment assignment;

  private List<UserMap> members;

  // private User superUser;
  /**
   * Team
   *
   * @param assignment Assignment
   */
  public Team(Assignment assignment) {
    this.assignment = assignment;
    this.members = new ArrayList<UserMap>();
  }

  private void copy(Team team) {
    Iterator<UserMap> maps = team.members.iterator();
    while (maps.hasNext()) {
      UserMap map = maps.next();
      for (int i = 0; i < map.getSize(); i++) {
        this.assign(map.getUser(), map.get(i));
      }
    }
  }

  public Object clone() {
    Team clone = new Team(this.assignment);
    clone.copy(this);
    return clone;
  }

  public boolean assign(User user, TeamRole teamRole) {
    boolean assigned = false;

    // check if the teamRole is indeed in the assignment model team
    boolean isTeamRole = assignment.getTeamModel().
        contains(teamRole);

    if (isTeamRole && user != null && teamRole != null) {

      // first try to get the map for the user in case it is already in the team.
      UserMap map = this.getMap(user);

      // if the user is not in the team, create a new map for him/her
      if (map == null) {
        map = new UserMap(user);
      }

      // try to map/assign the teamRole to the user
      assigned = map.assignTeamRole(teamRole);

      // if this succeeds, and the user is not in the team, add the user to the team
      if (assigned && !members.contains(map)) {
        members.add(map);
      }
    }
    return assigned;
  }

  public boolean disassignTeamRole(User user, TeamRole teamRole) {
    UserMap map = this.getMap(user);
    if (map != null) {
      return map.disassignTeamRole(teamRole);
    }
    return false;
  }

  public boolean teamRoleAssigned(TeamRole teamRole) {
    boolean assigned = false;
    int i = 0;
    while (!assigned && i < this.getSize()) {
      UserMap map = this.get(i++);
      assigned = map.hasTeamRole(teamRole);
    }
    return assigned;
  }

  public boolean canDisassignTeamRole(User user, TeamRole teamRole) {
    UserMap map = this.getMap(user);
    if (map != null) {
      return map.hasTeamRole(teamRole);
    }
    return false;
  }

  public boolean canAssign(User user, TeamRole teamRole) {
    boolean assigned = false;

    // check if the teamRole is indeed in the assignment model team
    boolean isTeamRole = assignment.getTeamModel().
        contains(teamRole);

    if (isTeamRole && user != null && teamRole != null) {

      // first try to get the map for the user in case it is already in the team.
      UserMap map = this.getMap(user);

      // if the user is not in the team, create a new map for him/her
      if (map == null) {
        map = new UserMap(user);
      }

      // try to map/assign the teamRole to the user
      assigned = map.canAssign(teamRole);
    }
    return assigned;
  }

  public UserMap getMap(User user) {
    boolean found = false;
    int i = 0;
    UserMap map = null;
    while (!found && i < this.getSize()) {
      map = this.get(i++);
      found = map.forUser(user);
    }
    return found ? map : null;
  }

  public UserMap get(int index) {
    if (index >= 0 && index < members.size()) {
      return members.get(index);
    }
    return null;
  }

  public int getSize() {
    return members.size();
  }

  /**
   * getStringMembers
   *
   * @param teamRole Role
   * @return String
   */
  public String getStringMembers(TeamRole teamRole) {
    String members = "";
    for (int i = 0; i < this.getSize(); i++) {
      UserMap map = this.get(i);
      if (map.hasTeamRole(teamRole)) {
        if (!members.equals("")) {
          members += ", ";
        }
        members += map.getUser().getFullName();
      }
    }
    return members;
  }

  /**
   * ok
   *
   * @return boolean
   */
  public boolean ok() {
    boolean result = true;
    TeamModel model = this.assignment.getTeamModel();
    int i = 0;
    while (result && i < model.getSize()) {
      TeamRole teamRole = model.get(i++);
      result = this.teamRoleAssigned(teamRole);
    }
    return result;
  }

  /**
   * isMember
   *
   * @param user User
   * @return boolean
   */
  public boolean isMember(User user) {
    if (user == Administrator.singleton()) {
      return true; // administrator is always member
    }
    return (this.getMap(user) != null);
  }

  public void superUser(User user) {
    TeamModel teamModel = assignment.getTeamModel();
    /* if ( teamModel.getSize() == 0 )
      teamModel.add(SuperRole.singleton());*/
    for (int i = 0; i < teamModel.getSize(); i++) {
      TeamRole role = teamModel.get(i);
      user.addRole(role.getRole());
      assign(user, role);
    }
  }

  public class UserMap {
    User user;
    List<TeamRole> teamRoles;

    public UserMap(User user) {
      this.user = user;
      teamRoles = new ArrayList<TeamRole>();
    }

    public Object clone() {
      UserMap clone = new UserMap(this.user);
      Iterator<TeamRole> i = teamRoles.iterator();
      while (i.hasNext()) {
        clone.assignTeamRole(i.next());
      }
      return clone;
    }

    public boolean forUser(User user) {
      return this.user == user;
    }

    public boolean canAssign(TeamRole teamRole) {
      if (this.hasTeamRole(teamRole)) {
        return false;
      }
      Role role = user.getRoleWithId(teamRole.getRole().getId());
      if (role != null){
    	  return false; 
      }
      return true;
    }

    public boolean assignTeamRole(TeamRole teamRole) {
      if (canAssign(teamRole)) {
        teamRoles.add(teamRole);
        return true;
      }
      return false;
    }

    public String toString() {
      return user.toString();
    }

    public int getSize() {
      return this.teamRoles.size();
    }

    public TeamRole get(int index) {
      TeamRole role = null;
      if (index >= 0) {
        if (index < this.teamRoles.size()) {
          role = this.teamRoles.get(index);
        }
      }
      return role;
    }

    public boolean hasTeamRole(TeamRole teamRole) {
      boolean contains = this.getId(teamRole.getId()) != null;
      contains = contains && (this.getName(teamRole.getName()) != null);
      return contains;
    }

    /**
     * getName
     *
     * @param name int
     * @return Role
     */
    public TeamRole getName(String name) {
      Iterator<TeamRole> it = teamRoles.iterator();
      TeamRole role = null;
      boolean found = false;
      while (it.hasNext() && !found) {
        role = it.next();
        found = (role.getName() == name);
      }
      return found ? role : null;
    }

    /**
     * getId
     *
     * @param anId int
     * @return Role
     */
    public TeamRole getId(int anId) {
      Iterator<TeamRole> it = this.teamRoles.iterator();
      TeamRole role = null;
      boolean found = false;
      while (it.hasNext() && !found) {
        role = it.next();
        found = (role.getId() == anId);
      }
      return found ? role : null;
    }

    public User getUser() {
      return this.user;
    }

    /**
     *
     * @param teamRole TeamRole
     * @return boolean
     */
    public boolean disassignTeamRole(TeamRole teamRole) {
      boolean result = this.hasTeamRole(teamRole);
      if (result) {
        result = this.teamRoles.remove(teamRole);
      }
      return result;
    }
  }

  public boolean authorized(Authorization authorization, User user) {
    if (user == Administrator.singleton()) {
      return true; // administrator is always authorized
    }
    if (authorization.count() == 0) {
      return true; // if no authorization roles, than everybody is authorized
    }
    
    if (authorization != null && user != null) {
    	UserMap map = this.getMap(user);
    	for (TeamRole role: authorization.getAuthorizedList()){
    		if (map.hasTeamRole(role)){
    			return true;
    		}
    	}
    }
    return false;
    
    /*boolean authorized = false;
    if (authorization != null && user != null) {
      Iterator<TeamRole> author = authorization.getAuthorizedList().iterator();
      UserMap map = this.getMap(user);
      while (author.hasNext() && !authorized) {
        TeamRole role = author.next();
        authorized = map.hasTeamRole(role);
      }
    }
    return authorized;*/
  }
}
