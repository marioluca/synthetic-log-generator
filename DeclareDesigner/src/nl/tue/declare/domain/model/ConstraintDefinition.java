/* Generated by Together */

package nl.tue.declare.domain.model;

import java.util.Collection;
import java.util.HashMap;
import java.util.HashSet;
import java.util.Iterator;
import java.util.Map;

import nl.tue.declare.domain.instance.State;
import nl.tue.declare.domain.template.ConstraintTemplate;
import nl.tue.declare.domain.template.Parameter;

public class ConstraintDefinition 
extends ConstraintTemplate {

	/**
	 * @clientCardinality 0..*
	 * @supplierCardinality 1
	 */
	private AssignmentModel assignmentModel;

	/**
	 * @clientCardinality 0..*
	 * @supplierCardinality 1
	 */

	private Condition condition;

	private boolean mandatory;

	private ConstraintLevel level;

	private HashMap<Parameter, HashSet<ActivityDefinition>> realParameters = new HashMap<Parameter, HashSet<ActivityDefinition>> ();


	public ConstraintDefinition(int anId, AssignmentModel anAssignmentModel,
			ConstraintTemplate anTemplate) {
		super(anId, anTemplate);
		this.setMandatory(true);
        
		assignmentModel = anAssignmentModel;
		condition = new Condition();
		this.level = null;
		for (Parameter p: this.parameters){
			realParameters.put(p, new HashSet<ActivityDefinition>());
		}
	}

	/**
	 * LTLConstraintDefinition call this constructor to create a constraint in the
	 * model based on a template
	 *
	 * @param definition ConstraintDefiniton -> copy all data from another definiton
	 */
	public ConstraintDefinition(ConstraintDefinition definition) {
		this(definition.getId() ,definition.assignmentModel,definition);
		this.setMandatory(definition.getMandatory());
		condition = definition.condition;
		this.level = definition.level;
		for (Map.Entry<Parameter, HashSet<ActivityDefinition>> entry: definition.realParameters.entrySet() ){
			Collection<ActivityDefinition> real =  realParameters.get(entry.getKey());
			real.addAll(entry.getValue());
		}
	}

	public Object clone() {
		ConstraintDefinition clone = new ConstraintDefinition(this);
		return clone;
	}

	protected void setAssignmentModel(AssignmentModel assignmentModel) {
		this.assignmentModel = assignmentModel;
	}

	protected AssignmentModel getAssignmentModel() {
		return this.assignmentModel;
	}

	/**
	 *
	 * @return Condition
	 */
	public Condition getCondition() {
		return condition;
	}

	/**
	 *
	 * @return boolean
	 */
	public boolean getMandatory() {
		return mandatory;
	}

	/**
	 *
	 * @return ConstraintLevel
	 */
	public ConstraintLevel getLevel() {
		return this.level;
	}

	/**
	 *
	 * @param level ConstraintLevel
	 */
	public void setLevel(ConstraintLevel level) {
		this.level = level;
		this.mandatory = (level == null);
	}

	/**
	 * depensOn
	 *
	 * @param activityDefinition ActivityDefinition
	 * @return boolean
	 */
	public boolean dependsOn(ActivityDefinition activityDefinition) {
		for (Parameter p: parameters){
			if (hasBranch(p,activityDefinition)){
				return true;
			}			
		}
		return false;
	}

	/**
	 * toString
	 *
	 * @return String
	 */
	public String toString() {
		return condition.getText();
	}

	/**
	 * equals
	 *
	 * @param anObject Object
	 * @return boolean
	 */
	public boolean equals(Object anObject) {
		boolean result = false;
		if (anObject != null) {
			if (anObject instanceof ConstraintDefinition) {
				ConstraintDefinition constraint = (ConstraintDefinition) anObject;
				result = (constraint.getId() == this.getId());
			}
		}
		return result;
	}
	
	/**
	 *
	 * @param mandatory boolean
	 */
	public void setMandatory(boolean mandatory) {
		this.mandatory = mandatory;
		if (mandatory) {
			this.level = null;
		}
	}

	public boolean hasBranch(Parameter p, ActivityDefinition real) {
		Iterator<ActivityDefinition> iterator = getBranches(p).iterator();
		boolean found = false;
		while (iterator.hasNext() && !found) {
			found = iterator.next().equals(real);
		}
		return found;
	}



	public boolean addBranch(Parameter p, ActivityDefinition real) {
		return realParameters.get(p).add(real);
	}



	/**
	 * deleteBranch
	 *
	 * @param activityDefinition AbstractEvent
	 * @return boolean
	 */
	public void deleteBranch(Parameter p, ActivityDefinition real) {
		realParameters.get(p).remove(real);
	}

	/**
	 * branchesCount
	 *
	 * @return int
	 */
	public int branchesCount(Parameter p) {
		return realParameters.get(p).size();
	}

	/**
	 * branchAt
	 *
	 * @param index int
	 * @return AbstractEvent
	 */
	/*public ActivityDefinition branchAt(Parameter p, int index) {
		if (index > branchesCount(p)) {
			return null;
		}
		return getBranches(p).get(index);
	}*/

	/**
	 * getBranch
	 *
	 * @param activityDefinition ActivityDefinition
	 * @return boolean
	 */

	/*public ActivityDefinition getBranch(Parameter p, ActivityDefinition real) {
		boolean found = false;
		ActivityDefinition branch = null;
		Iterator<ActivityDefinition> i = this.getBranches(p).iterator();
		while ( (!found) && i.hasNext()) {
			branch = i.next();
			if (branch.equals(real)){
				return branch;
			}
		}
		return null;
	}*/

	public Collection<ActivityDefinition> getBranches(Parameter p){
		return realParameters.get(p);
	}


	/**
	 * isBranched
	 *
	 * @return boolean
	 */
	public boolean isBranched(Parameter p) {
		boolean result = p.isBranchable() ? (!realParameters.get(p).isEmpty()) : false;
		return result;
	}

	/**
	 * Returns the index of a branch with the job descritpion.
	 * @param activityDefinition ActivityDefinition
	 * @return The index of a branch with the job descritpion. -1 if the branch
	 * with the job decsription has not been found
	 */
	public int isBranchAt(Parameter p, ActivityDefinition real) {
		int i = 0;
		Iterator<ActivityDefinition> iterator = getBranches(p).iterator();
		boolean found = false;
		while (iterator.hasNext() && !found) {
			ActivityDefinition branch = iterator.next();
			found = branch.equals(real);
			i++;
		}
		return found ? i - 1 : -1;
	}


	public void clearBranches(Parameter p){
		this.realParameters.get(p).clear();
	}
	public void cleanAllParameterBranches(){
		for (Map.Entry<Parameter, HashSet<ActivityDefinition>> entry: realParameters.entrySet() ){
			realParameters.get(entry.getKey()).clear();
		} 
	}

	public ActivityDefinition getFirstBranch(Parameter p){
		Iterator<ActivityDefinition> branches = getBranches(p).iterator();
		if (branches.hasNext()){
			return branches.next();
		}
		return null;
	}
	
	public String getDescription(){
		 return replaceParameters(super.getDescription());
	}

	public String getStateMessage(State state){
		return replaceParameters(super.getStateMessage(state));
	}

	private String replaceParameters(String s){
		String msg = new String(s);
		for (Parameter p: parameters){
			String real = "";
			for (ActivityDefinition branch: this.getBranches(p)){
				if (!real.equals("")){
					real += " or ";
				} 
				real += "<b>"+branch.getName()+"</b>";				  
			}			 
			String quote = msg.contains("&quot;")?"&quot;":"\"";
			msg = msg.replaceAll(quote+p.getName()+quote, real);
		}
		return msg;		
	}

	public String getCaption() {
		    return getName() + ": " + parameters() + "";
		  }

		  private  String parameters() {
		    String result = "";
		    for (Parameter parameter: this.parameters) {
		      if (!result.equals("")) {
		        result += ", ";
		      }
		      result += branches(parameter);

		    }
		    return result;
		  }

		  /**
		   *
		   * @param parameter Parameter
		   * @return String
		   */
		  private String branches(Parameter parameter) {
		    String result = "";
		    for (ActivityDefinition branch: getBranches(parameter)) {
		      if (!result.equals("")) {
		        result += ", ";
		      }
		      result += branch.getName();
		    }
		    return "[" + result + "]";
		  }
}
